/* *
 * Scanner for the class project in COP5556 Programming Language Principles 
 * at the University of Florida, Fall 2017.
 * 
 * This software is solely for the educational benefit of students 
 * enrolled in the course during the Fall 2017 semester.  
 * 
 * This software, and any software derived from it,  may not be shared with others or posted to public web sites,
 * either during the course or afterwards.
 * 
 *  @Beverly A. Sanders, 2017
  */

package cop5556fa17;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class Scanner {
	
	@SuppressWarnings("serial")
	public static class LexicalException extends Exception {
		
		int pos;

		public LexicalException(String message, int pos) {
			super(message);
			this.pos = pos;
		}
		
		public int getPos() { return pos; }

	}

	public static enum Kind {
		IDENTIFIER, INTEGER_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, 
		KW_x/* x */, KW_X/* X */, KW_y/* y */, KW_Y/* Y */, KW_r/* r */, KW_R/* R */, KW_a/* a */, 
		KW_A/* A */, KW_Z/* Z */, KW_DEF_X/* DEF_X */, KW_DEF_Y/* DEF_Y */, KW_SCREEN/* SCREEN */, 
		KW_cart_x/* cart_x */, KW_cart_y/* cart_y */, KW_polar_a/* polar_a */, KW_polar_r/* polar_r */, 
		KW_abs/* abs */, KW_sin/* sin */, KW_cos/* cos */, KW_atan/* atan */, KW_log/* log */, 
		KW_image/* image */,  KW_int/* int */, 
		KW_boolean/* boolean */, KW_url/* url */, KW_file/* file */, OP_ASSIGN/* = */, OP_GT/* > */, OP_LT/* < */, 
		OP_EXCL/* ! */, OP_Q/* ? */, OP_COLON/* : */, OP_EQ/* == */, OP_NEQ/* != */, OP_GE/* >= */, OP_LE/* <= */, 
		OP_AND/* & */, OP_OR/* | */, OP_PLUS/* + */, OP_MINUS/* - */, OP_TIMES/* * */, OP_DIV/* / */, OP_MOD/* % */, 
		OP_POWER/* ** */, OP_AT/* @ */, OP_RARROW/* -> */, OP_LARROW/* <- */, LPAREN/* ( */, RPAREN/* ) */, 
		LSQUARE/* [ */, RSQUARE/* ] */, SEMI/* ; */, COMMA/* , */, EOF;
	}
	
	public static enum State{
		START, AFTER_EQUAL, AFTER_NOT, AFTER_MINUS,
		AFTER_LESSTHAN, AFTER_GREATERTHAN,
		AFTER_ASTERISK, IN_DIGIT, IN_IDENT,
		AFTER_FORWARDSLASH,
		INCOMMENT, IN_STRINGLITERAL
	}

	/** Class to represent Tokens. 
	 * 
	 * This is defined as a (non-static) inner class
	 * which means that each Token instance is associated with a specific 
	 * Scanner instance.  We use this when some token methods access the
	 * chars array in the associated Scanner.
	 * 
	 * 
	 * @author Beverly Sanders
	 *
	 */
	public class Token {
		public final Kind kind;
		public final int pos;
		public final int length;
		public final int line;
		public final int pos_in_line;

		public Token(Kind kind, int pos, int length, int line, int pos_in_line) {
			super();
			this.kind = kind;
			this.pos = pos;
			this.length = length;
			this.line = line;
			this.pos_in_line = pos_in_line;
		}

		public String getText() {
			if (kind == Kind.STRING_LITERAL) {
				return chars2String(chars, pos, length);
			}
			else return String.copyValueOf(chars, pos, length);
		}

		/**
		 * To get the text of a StringLiteral, we need to remove the
		 * enclosing " characters and convert escaped characters to
		 * the represented character.  For example the two characters \ t
		 * in the char array should be converted to a single tab character in
		 * the returned String
		 * 
		 * @param chars
		 * @param pos
		 * @param length
		 * @return
		 */
		private String chars2String(char[] chars, int pos, int length) {
			StringBuilder sb = new StringBuilder();
			for (int i = pos + 1; i < pos + length - 1; ++i) {// omit initial and final "
				char ch = chars[i];
				if (ch == '\\') { // handle escape
					i++;
					ch = chars[i];
					switch (ch) {
					case 'b':
						sb.append('\b');
						break;
					case 't':
						sb.append('\t');
						break;
					case 'f':
						sb.append('\f');
						break;
					case 'r':
						sb.append('\r'); //for completeness, line termination chars not allowed in String literals
						break;
					case 'n':
						sb.append('\n'); //for completeness, line termination chars not allowed in String literals
						break;
					case '\"':
						sb.append('\"');
						break;
					case '\'':
						sb.append('\'');
						break;
					case '\\':
						sb.append('\\');
						break;
					default:
						assert false;
						break;
					}
				} else {
					sb.append(ch);
				}
			}
			return sb.toString();
		}

		/**
		 * precondition:  This Token is an INTEGER_LITERAL
		 * 
		 * @returns the integer value represented by the token
		 */
		public int intVal() {
			assert kind == Kind.INTEGER_LITERAL;
			return Integer.valueOf(String.copyValueOf(chars, pos, length));
		}
		


		public String toString() {
			return "[" + kind + "," + String.copyValueOf(chars, pos, length)  + "," + pos + "," + length + "," + line + ","
					+ pos_in_line + "]";
		}

		/** 
		 * Since we overrode equals, we need to override hashCode.
		 * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-
		 * 
		 * Both the equals and hashCode method were generated by eclipse
		 * 
		 */
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((kind == null) ? 0 : kind.hashCode());
			result = prime * result + length;
			result = prime * result + line;
			result = prime * result + pos;
			result = prime * result + pos_in_line;
			return result;
		}

		/**
		 * Override equals method to return true if other object
		 * is the same class and all fields are equal.
		 * 
		 * Overriding this creates an obligation to override hashCode.
		 * 
		 * Both hashCode and equals were generated by eclipse.
		 * 
		 */
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Token other = (Token) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (kind != other.kind)
				return false;
			if (length != other.length)
				return false;
			if (line != other.line)
				return false;
			if (pos != other.pos)
				return false;
			if (pos_in_line != other.pos_in_line)
				return false;
			return true;
		}

		/**
		 * used in equals to get the Scanner object this Token is 
		 * associated with.
		 * @return
		 */
		private Scanner getOuterType() {
			return Scanner.this;
		}

	}

	/** 
	 * Extra character added to the end of the input characters to simplify the
	 * Scanner.  
	 */
	static final char EOFchar = 0;
	
	/**
	 * The list of tokens created by the scan method.
	 */
	final ArrayList<Token> tokens;
	
	/**
	 * An array of characters representing the input.  These are the characters
	 * from the input string plus and additional EOFchar at the end.
	 */
	final char[] chars;  



	
	/**
	 * position of the next token to be returned by a call to nextToken
	 */
	private int nextTokenPos = 0;

	Scanner(String inputString) {
		int numChars = inputString.length();
		this.chars = Arrays.copyOf(inputString.toCharArray(), numChars + 1); // input string terminated with null char
		chars[numChars] = EOFchar;
		tokens = new ArrayList<Token>();
	}


	/**
	 * Method to scan the input and create a list of Tokens.
	 * 
	 * If an error is encountered during scanning, throw a LexicalException.
	 * 
	 * @return
	 * @throws LexicalException
	 */
	public Scanner scan() throws LexicalException {
		
		
		int pos = 0;
		int line = 1;
		int posInLine = 1;
		State state = State.START;
		int startPos = 0;
		
	
		//Map to store all the reserved words
		HashMap<String, Kind> reservedMap = new HashMap<>();
		
		reservedMap.put("IDENTIFIER",Kind.IDENTIFIER );
		reservedMap.put("INTEGER_LITERAL",Kind.INTEGER_LITERAL );
		reservedMap.put("BOOLEAN_LITERAL",Kind.BOOLEAN_LITERAL );
		reservedMap.put("STRING_LITERAL",Kind.STRING_LITERAL );
		reservedMap.put("x",Kind.KW_x );
		reservedMap.put("X",Kind.KW_X );
		reservedMap.put("y",Kind.KW_y );
		reservedMap.put("Y",Kind.KW_Y );
		reservedMap.put("r",Kind.KW_r );
		reservedMap.put("R",Kind.KW_R );
		reservedMap.put("a",Kind.KW_a );
		reservedMap.put("A",Kind.KW_A );
		reservedMap.put("Z",Kind.KW_Z );
		reservedMap.put("DEF_X",Kind.KW_DEF_X );
		reservedMap.put("DEF_Y",Kind.KW_DEF_Y );
		reservedMap.put("SCREEN",Kind.KW_SCREEN );
		reservedMap.put("cart_x",Kind.KW_cart_x );
		reservedMap.put("cart_y",Kind.KW_cart_y );
		reservedMap.put("polar_a",Kind.KW_polar_a );
		reservedMap.put("polar_r",Kind.KW_polar_r );
		reservedMap.put("abs", Kind.KW_abs );
		reservedMap.put("sin", Kind.KW_sin );
		reservedMap.put("cos", Kind.KW_cos );
		reservedMap.put("atan", Kind.KW_atan );
		reservedMap.put("log", Kind.KW_log );
		reservedMap.put("image", Kind.KW_image );
		reservedMap.put("int", Kind.KW_int );
		reservedMap.put("boolean", Kind.KW_boolean);
		reservedMap.put("url", Kind.KW_url );
		reservedMap.put("file", Kind.KW_file );
		reservedMap.put("ASSIGN", Kind.OP_ASSIGN );
		reservedMap.put("GT", Kind.OP_GT );
		reservedMap.put("LT", Kind.OP_LT );
		reservedMap.put("EXCL", Kind.OP_EXCL );
		reservedMap.put("Q", Kind.OP_Q );
		reservedMap.put("COLON", Kind.OP_COLON );
		reservedMap.put("EQ", Kind.OP_EQ );
		reservedMap.put("NEQ", Kind.OP_NEQ );
		reservedMap.put("GE", Kind.OP_GE );
		reservedMap.put("LE", Kind.OP_LE );
		reservedMap.put("AND", Kind.OP_AND );
		reservedMap.put("OR", Kind.OP_OR );
		reservedMap.put("PLUS", Kind.OP_PLUS );
		reservedMap.put("MINUS", Kind.OP_MINUS );
		reservedMap.put("TIMES", Kind.OP_TIMES );
		reservedMap.put("DIV", Kind.OP_DIV );
		reservedMap.put("MOD", Kind.OP_MOD );
		reservedMap.put("POWER", Kind.OP_POWER );
		reservedMap.put("AT", Kind.OP_AT );
		reservedMap.put("RARROW", Kind.OP_RARROW );
		reservedMap.put("LARROW", Kind.OP_LARROW );
		reservedMap.put("LPAREN", Kind.LPAREN );
		reservedMap.put("RPAREN", Kind.RPAREN );
		reservedMap.put("LSQUARE", Kind.LSQUARE );
		reservedMap.put("RSQUARE", Kind.RSQUARE );
		reservedMap.put("SEMI", Kind.SEMI );
		reservedMap.put("COMMA", Kind.COMMA );
		reservedMap.put("EOF", Kind.EOF );

		while(pos < chars.length) {
			switch(state) {
				case START:{
					startPos = pos;
					switch(chars[pos]) {
						
						/* Check for EndOfCharacter */
						case EOFchar: {
							tokens.add(new Token(Kind.EOF, pos, 0, line, posInLine));
							pos++;
						}
						break;
					
						/* Adding Separators */
						case '(' : {
							tokens.add(new Token(Kind.LPAREN ,pos,1,line,posInLine));
							posInLine++;
							pos++;	
						}
						break;
						case ')' : {
							tokens.add(new Token(Kind.RPAREN ,pos,1,line,posInLine));
							posInLine++;
							pos++;	
						}
						break;
						case '[' : {
							tokens.add(new Token(Kind.LSQUARE ,pos,1,line,posInLine));
							posInLine++;
							pos++;	
						}
						break;
						case ']' : {
							tokens.add(new Token(Kind.RSQUARE ,pos,1,line,posInLine));
							posInLine++;
							pos++;	
						}
						break;							
						case ';' : {
							tokens.add(new Token(Kind.SEMI,pos,1,line,posInLine));
							posInLine++;
							pos++;	
						}
						break;
						case ',' : {
							tokens.add(new Token(Kind.COMMA ,pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						/* Separators done */
						
						/* Adding Operators */
						case '&': {
							tokens.add(new Token(Kind.OP_AND, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						case '|': {
							tokens.add(new Token(Kind.OP_OR, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						case '+': {
							tokens.add(new Token(Kind.OP_PLUS, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						case '%': {
							tokens.add(new Token(Kind.OP_MOD, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						case '@': {
							tokens.add(new Token(Kind.OP_AT, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						case '?': {
							tokens.add(new Token(Kind.OP_Q, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						case ':': {
							tokens.add(new Token(Kind.OP_COLON, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						case '=': {
							state = State.AFTER_EQUAL;
							pos++;
							
						}
						break;
						case '!': {
							state = State.AFTER_NOT;
							pos++;
						}
						break;
						case '-': {
							state = State.AFTER_MINUS;
							pos++;
						}
						break;
						case '<': {
							state = State.AFTER_LESSTHAN;
							pos++;
						}
						break;
						case '>': {
							state = State.AFTER_GREATERTHAN;
							pos++;
						}
						break;
						case '*': {
							state = State.AFTER_ASTERISK;
							pos++;
						}
						break;
						/*Operators done*/
						case '0': {
							tokens.add(new Token(Kind.INTEGER_LITERAL, pos,1,line,posInLine));
							posInLine++;
							pos++;
						}
						break;
						/*Integer Literal done */
						
						
						case '/': {
							state = State.AFTER_FORWARDSLASH;
							pos++;
						}
						break;
						
						case '\n': {
							line++;
							posInLine = 1;
							pos++;
						}
						break;
						
						case '\r': {
							if( chars[pos+1] == '\n' )
								pos++;
							line++;
							posInLine = 1;
							pos++;
						}
						break;
						
					
						
						case '\"': {
							pos++;
							state = State.IN_STRINGLITERAL;
						}
						break;
						
						
					
						default: {
							
							if(chars[pos] > 255)
								throw new LexicalException("Not an ASCII character at line " + line,pos);
							
							else if( chars[pos] == ' ' ||  chars[pos] == '\t' || chars[pos] == '\f') {
								//Check if it is a whitespace
								//Line Terminators are handled on top 
								pos++;
								posInLine++;
							}
								
							//Check if it is a digit
							else if(chars[pos] > '0' && chars[pos] <= '9') {
								state = State.IN_DIGIT;
								pos++;
							}
							
							//Check if it is a StringLiteral
							else if(chars[pos] == '_' || chars[pos] == '$' || (chars[pos] >= 'a' && chars[pos] <= 'z') || (chars[pos] >= 'A' && chars[pos] <= 'Z') ) {
								state = State.IN_IDENT;
								pos++;
							}
							
							else
								throw new LexicalException("Character at line " + line + " is not allowed", pos);
							
							
						}
							
									
 					}
				}
				break;
				
				case AFTER_EQUAL: {
					switch(chars[pos]) {
						case '=': {
							//Implementation for == operator
							tokens.add(new Token(Kind.OP_EQ,startPos, 2, line, posInLine));
							pos++;
							posInLine += 2;
							state = State.START;
						}
						break;
						
						default:
						{
							//Implementation for = operator
							tokens.add(new Token(Kind.OP_ASSIGN, startPos,1, line, posInLine));
							posInLine++;
							state = State.START;
						}
							
					}
						
				}
				break;
				
				case AFTER_NOT: {
					switch(chars[pos]) {
						case '=': {
							//Implementation for != operator
							tokens.add(new Token(Kind.OP_NEQ, startPos, 2, line, posInLine));
							pos++;
							posInLine += 2;
							state = State.START;
						}
						break;
						
						default: {
							//Implementation for !
							tokens.add(new Token(Kind.OP_EXCL, startPos, 1, line, posInLine));
							posInLine++;
							state = State.START;
						}		
					}
				}
				break;
				
				case AFTER_MINUS: {
					switch(chars[pos]) {
						case '>': {
							//Implementation for -> operator
							tokens.add(new Token(Kind.OP_RARROW, startPos, 2, line, posInLine));
							pos++;
							posInLine += 2;
							state = State.START;
						}
						break;
						
						default: {
							//Implementation for -
							tokens.add(new Token(Kind.OP_MINUS, startPos, 1, line, posInLine));
							posInLine++;
							state = State.START;
						}		
					}
				}
				break;
				
				case AFTER_LESSTHAN: {
					switch(chars[pos]) {
						case '=': {
							//Implementation for <=
							tokens.add(new Token(Kind.OP_LE, startPos, 2, line, posInLine));
							pos++;
							posInLine += 2;
							state = State.START;
						}
						break;
						
						case '-': {
							//Implementation for <-
							tokens.add(new Token(Kind.OP_LARROW, startPos, 2, line, posInLine));
							pos++;
							posInLine += 2;
							state = State.START;
						}
						break;
						
						default: {
							//Implementation for <
							tokens.add(new Token(Kind.OP_LT, startPos, 1, line, posInLine));
							posInLine++;
							state = State.START;
						}
							
					}
				}
				break;
				
				case AFTER_GREATERTHAN: {
					switch(chars[pos]) {
						case '=': {
							//Implementation for >=
							tokens.add(new Token(Kind.OP_GE, startPos, 2, line, posInLine));
							pos++;
							posInLine += 2;
							state = State.START;
						}
						break;
						
						default: {
							//Implementation for >
							tokens.add(new Token(Kind.OP_GT, startPos, 1, line, posInLine));
							posInLine++;
							state = State.START;
						}
					}
				}
				break;
				
				case AFTER_ASTERISK: {
					switch(chars[pos]) {
						case '*' :{
							//Implementation for **
							tokens.add(new Token(Kind.OP_POWER, startPos, 2, line, posInLine));
							pos++;
							posInLine += 2;
							state = State.START;
						}
						break;
						default: {
							//Implementation for *
							tokens.add(new Token(Kind.OP_TIMES, startPos, 1, line, posInLine));
							posInLine++;
							state = State.START;
						}
						
						
						
					}
				}
				break;
				
				case IN_DIGIT: {
					char c = chars[pos];
					if( c >= '0' && c <= '9' ) {
						pos++;
					}
					else {
						//Before adding the no in the token, check if it is in the integer range
						//If not in the range, then throw exception
						
						try {
							Integer.parseInt(new String(chars).substring(startPos, pos));
						}
						catch(NumberFormatException e) {
							
							throw new LexicalException("Parsed number not in Integer Range. Error found at line "+ line+ " at col" + posInLine, startPos);
						}
						tokens.add(new Token(Kind.INTEGER_LITERAL, startPos, pos - startPos, line, posInLine));
						posInLine += (pos-startPos);
						state = State.START;
					}	
				}
				break;
				
				case IN_IDENT: {
					
					char c = chars[pos];
					if( ( c == '_' || c == '$' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || 
						(c >= '0' && c <= '9')) ) {
						pos++;	
					}
					else {
						//The identifier has ended, now check if its a boolean literal or keyword,if not save it as an identifier token
						String temp = new String(chars).substring(startPos, pos);
						if( temp.equals("true") || temp.equals("false")) {
							tokens.add(new Token(Kind.BOOLEAN_LITERAL, startPos, pos-startPos, line, posInLine));
						}
							
						else if(reservedMap.containsKey(temp)) {
							//Reserved word found
							tokens.add(new Token(reservedMap.get(temp), startPos, pos-startPos, line, posInLine));
							
						}
						else {
							//Identifier found
							tokens.add( new Token(Kind.IDENTIFIER, startPos, pos-startPos, line, posInLine));
							
						}
						posInLine += (pos-startPos);
						state = State.START;
					}
				}
				break;
								
				case AFTER_FORWARDSLASH: {
					if(chars[pos] == '/') {
							//Implementation for comments
						pos++;
						state = State.INCOMMENT;
					}
					else {
						//Division symbol
						tokens.add(new Token(Kind.OP_DIV, startPos, 1, line, posInLine));
						posInLine++;
						state = State.START;
						
						
					}
				}
				break;
				
				case INCOMMENT: {
					if( chars[pos] == EOFchar )
						state = State.START;
					
					else if(chars[pos] == '\r') {
						if( chars[pos+1] == '\n') {
							pos++;
						}
						line++;
						pos++;
						posInLine = 1;
						state = State.START;
						
					}
					
					else if(chars[pos]=='\n') {
						
						line++;
						pos++;
						posInLine = 1;
						state = State.START;
					}
					else {
						
						pos++;
					}
						
						
				}
				break;
				
				case IN_STRINGLITERAL: {
					if(chars[pos] > 255)
						throw new LexicalException("Not an ASCII character at line " + line,pos);
					else if( chars[pos] == '\n')
						throw new LexicalException("LF is not allowed in String Literal",pos);
					else if( chars[pos] == '\r')
						throw new LexicalException("CR is not allowed in String Literal", pos);
					else if( chars[pos] == '"' && chars[pos] != '\"')
						throw new LexicalException("Double quotes not allowed in String Literal", pos);
					
					else if( chars[pos] ==  '\"')  { 
						pos++;
						tokens.add(new Token(Kind.STRING_LITERAL, startPos, pos-startPos, line, posInLine));
						state = State.START;
						posInLine += (pos-startPos);
						
					}
					
					else if(chars[pos] == '\\') {
						pos++;
						switch(chars[pos]) {
							case 'b': { pos++; break; }								
							case 't': { pos++; break; }
							case 'n': { pos++; break; }
							case 'f': { pos++; break; }
							case 'r': { pos++; break; }
							case '\'': { pos++;break; }
							case '\"' : {pos++; break; }
							case '\\': { pos++; break; }
						
							default: 
								throw new LexicalException("BackSlash is not allowed in String Literal", pos);
						}
					}
					
					else if( chars[pos] == EOFchar)
						throw new LexicalException("String Literal not terminated", pos);
					
					else 
						pos++;

				}
				break;
				default:
					//Not needed
					throw new LexicalException("Undefined state", pos);
					
					
			}
		}
	
		//tokens.add(new Token(Kind.EOF, pos, 0, line, posInLine));
		return this;
	}


	/**
	 * Returns true if the internal interator has more Tokens
	 * 
	 * @return
	 */
	public boolean hasTokens() {
		return nextTokenPos < tokens.size();
	}

	/**
	 * Returns the next Token and updates the internal iterator so that
	 * the next call to nextToken will return the next token in the list.
	 * 
	 * It is the callers responsibility to ensure that there is another Token.
	 * 
	 * Precondition:  hasTokens()
	 * @return
	 */
	public Token nextToken() {
		return tokens.get(nextTokenPos++);
	}
	
	/**
	 * Returns the next Token, but does not update the internal iterator.
	 * This means that the next call to nextToken or peek will return the
	 * same Token as returned by this methods.
	 * 
	 * It is the callers responsibility to ensure that there is another Token.
	 * 
	 * Precondition:  hasTokens()
	 * 
	 * @return next Token.
	 */
	public Token peek() {
		return tokens.get(nextTokenPos);
	}
	
	
	/**
	 * Resets the internal iterator so that the next call to peek or nextToken
	 * will return the first Token.
	 */
	public void reset() {
		nextTokenPos = 0;
	}

	/**
	 * Returns a String representation of the list of Tokens 
	 */
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append("Tokens:\n");
		for (int i = 0; i < tokens.size(); i++) {
			sb.append(tokens.get(i)).append('\n');
		}
		return sb.toString();
	}

}
